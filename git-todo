#!/usr/local/bin/python

from datetime import datetime
import os
import shutil
import re
import argparse
import sys
import fileinput
import json
from pprint import pprint, pformat
import logging

from enum import Enum

from gitignore_parser import parse_gitignore

class ToDoStatus(Enum):
    NEW = "new"
    OPEN = "open"
    IN_PROGRESS = "in progress"
    finished = "finished"
    CANCELLED = "cancelled"

status_symbols = {
        "new" : '+',
        "open" : ' ',
        "in-progress" : '-',
        'finished' : 'X',
        'cancelled' : '/'
        }

# invert the status_symbols dictionary for getting status from the symbol
status_lookup = dict([[v,k] for k,v in status_symbols.items()])


# [486c4811] [+] P0 TODO: make this a context manager
def replace_lines(dirpath, fname, lines_to_replace, tmp_ext = '.gittodo.bak'):   
    tmp_name = os.path.join(dirpath,fname+tmp_ext)
    if os.path.exists(tmp_name):
        raise ValueError
    shutil.move(os.path.join(dirpath,fname), tmp_name)

    with open(tmp_name, 'r') as infile:
        with open(os.path.join(dirpath,fname), 'w') as outfile:
            for ln,line in enumerate(infile.readlines()):
                if lines_to_replace: lineno,replacement = lines_to_replace[0]
                if ln == lineno:
                    outfile.write(replacement)#.replace('\n',''))
                    lines_to_replace.pop(0)
                else:
                    outfile.write(line)#.replace('\n',''))

    os.remove(tmp_name)

def replace_line(dirpath, fname, lineno, replacement, tmp_ext = '.gittodo.bak'):   
    tmp_name = os.path.join(dirpath,fname+tmp_ext)
    if os.path.exists(tmp_name):
        raise ValueError
    shutil.move(os.path.join(dirpath,fname), tmp_name)
    
    with open(tmp_name, 'r') as infile:
        with open(os.path.join(dirpath,fname), 'w') as outfile:
            for ln,line in enumerate(infile.readlines()):
                if ln == lineno:
                    outfile.write(replacement)#.replace('\n',''))
                else:
                    outfile.write(line)#.replace('\n',''))
    
    os.remove(tmp_name)


'''
the default regex will match stuff like below, after and not including the '`':
`# TODO: this is a new todo item
`# TODO this is also a new todo item
`# [UUID] [ ] TODO: this is a task [UUID]
`//[ ] P0 this is a task [UUID]

The '`' (backtick) can be used to ignore a todo item
'''
# https://regex101.com/r/gM4pI1/63
TODO_REGEX_STR = "(?P<ignore>[`]){,1}(?P<comment>(#|(/{2})))+\s*(\[(?P<uuid>[0-9a-f]{8})\]){,1}\s*(\[(?P<status>[\+ -/X])\])*\s*(P(?P<priority>[0-9]+))*\s*TODO:*\s*(?P<desc>.+)"
TODO_REGEX = re.compile(TODO_REGEX_STR)

class ToDo(object):
    def __init__(self, description, 
            status = 'new', 
            priority = 0, 
            branch = None, 
            due = None,
            created = None, 
            updated = None, 
            uuid = None, 
            loc = None,
            category = None):

        self._status = status
        self._desc = description
        self._branch = branch
        self._priority = priority
        self._due = due
        self._created = created if created else datetime.now()
        self._updated = updated if updated else self._created
        self._loc = loc
        self._category = category

        self._uuid = uuid if uuid else self.uuid

    @property
    def uuid(self):
        return self._uuid if hasattr(self,'_uuid') else hex(hash(str(self._desc) + str(self._loc)))[-9:-1]

    @property
    def symbol(self):
        return status_symbols[self._status]

    @property
    def status(self):
        return self._status

    def __str__(self):
        return f"[{self.uuid}] [{self.symbol}] P{self._priority} TODO: {self._desc}"

    def as_dict(self):
        return {'status': self._status, 'desc': self._desc, 'priority' : self._priority,
                'created' : self._created, 'loc': self._loc, 'uuid': self._uuid }


    @classmethod
    def from_str(cls, string, expr = None):
        if not expr: expr = TODO_REGEX
        match = expr.match(string)

        status = status_lookup[match.group('status')]
        todo = cls(description = match.group('desc'), status = status,
                priority = match.group('priority'), uuid = match.group('uuid'))
        return todo
    
    @classmethod
    def from_dict(cls, d):
        if any(type(item) == ToDo for item in d.values()): return d
        return cls(description = d['desc'], status = d['status'], priority = d['priority'],
                uuid = d['uuid'], loc = d['loc'])

class ToDoEncoder(json.JSONEncoder):
    def default(self, o):
        if type(o) is datetime:
            return str(o)
        elif type(o) is ToDo:
            return o.as_dict()
        else:
            raise TypeError

class ToDoList(object):
    def __init__(self, 
            todos = { },
            root = os.popen('git rev-parse --show-toplevel').read().strip(),
            fname = '.todo',
            ):
        self._root = root
        self._fname = fname
        self._todos = todos

        parser = argparse.ArgumentParser()
        parser.add_argument('-d', '--debug', help='Debug mode', action='store_true')
        subparsers = parser.add_subparsers(help='sub-command help', dest='subparser_name')

        p_add = subparsers.add_parser('add', help='add a new todo item')
        p_add.add_argument('--branch')
        p_add.add_argument('-p', '--priority', help='Priority number for the new todo')
        p_add.add_argument('--due', help='Set a due date')
        p_add.add_argument('description', help='The description of the todo item')
        p_add.set_defaults(func=self.git_todo_add)

        p_edit = subparsers.add_parser('edit', help='edit an existing todo item',
                aliases = ['workon','finish','cancel','reopen'])
        p_edit.add_argument('uuid', help='uuid of todo item to edit')
        p_edit.add_argument('-p','--priority', help='set the priority')
        p_edit.add_argument('-d','--description', help='set the description')
        p_edit.add_argument('-s','--status', help='set the status', choices = status_symbols.keys())
        p_edit.add_argument('--due', help='set the due date')
        p_edit.add_argument('-c', '--category', help='set the category')
        p_edit.add_argument('-b', '--branch', help='set the branch')
        p_edit.set_defaults(func=self.git_todo_edit)

        p_detail = subparsers.add_parser('detail', help='show details of an existing todo item')
        p_detail.add_argument('uuid', help='uuid of todo item to show')
        p_detail.set_defaults(func=self.git_todo_detail)

        p_list = subparsers.add_parser('list', help='list existing todo items')
        p_list.add_argument('--sort', choices = ['priority', 'created', 'updated', 'status'])
        group = p_list.add_mutually_exclusive_group()
        group.add_argument('--show', choices = ['new', 'open', 'in-progress', 'finished', 'cancelled', 'closed'])
        group.add_argument('--new', action = 'store_true')
        group.add_argument('--open', action = 'store_true')
        group.add_argument('--in-progress', action = 'store_true')
        group.add_argument('--finished', action = 'store_true')
        group.add_argument('--cancelled', action = 'store_true')
        group.add_argument('--closed', action = 'store_true')
        p_list.set_defaults(func=self.git_todo_list)

        p_scan = subparsers.add_parser('scan', help='scan files for todo items')
        p_scan.add_argument('-f', '--file', help = 'Scan a specific file')
        p_scan.add_argument('-i', '--ignore', help = 'Ignore a specific file or pattern')
        p_scan.add_argument('--ignore-from', help = 'ignore from specified file. Follows .gitignore glob syntax')
        p_scan.add_argument('--inplace', help = "Track todo items in-place in the source files where they're found",
                action='store_true')
        p_scan.set_defaults(func=self.git_todo_scan)

        args = parser.parse_args()

        self._debug = args.debug
        logging.basicConfig(stream = sys.stdout)
        self.logger = logging.getLogger('git-todo')
        if self._debug: self.logger.setLevel(logging.DEBUG)
        else: self.logger.setLevel(logging.INFO)

        self.logger.debug(args)

        self.read_todos()
        
        if hasattr(args, 'func'):
            args.func(args)
        else:
            args = parser.parse_args("list".split())
            self.git_todo_list(args)

    def add_todo(self, todo):
        if todo.uuid in self._todos:
            t = self._todos[todo.uuid]
            if todo._loc != t._loc or todo._desc or t._desc:
                ans = input(f"Which do you want to keep?\n1. {todo}\n2. {self._todos[todo.uuid]}\n1|2 [1]: ")
                if ans == '1':
                    self._todos[todo.uuid] = todo
                elif ans == '2':
                    self._todos[todo.uuid] = t
                else:
                    raise ValueError
        else:
            self._todos[todo.uuid] = todo

    def get_todo(self, uuid):
        try:
            return self._todos[uuid]
        except KeyError as e:
            self.logger.error(f"uuid {uuid} does not exist")
            sys.exit(1)

    def git_todo_add(self, args):
        t = ToDo(args.description, priority=int(args.priority) if args.priority else 0,
                due = args.due if args.due else None)
        self.add_todo(t)
        
    def git_todo_edit(self, args):
        t = self.get_todo(args.uuid)
    
        if args.subparser_name == 'edit':
            if args.priority: t._priority = int(args.priority)
            if args.description: t._desc = args.description
            if args.status: t._status = args.status
            if args.due: t._due = datetime.fromisoformat(args.due)
            # [957f6b59] [+] P0 TODO: check if category exists
            if args.category: t._category = category 
            # [9b486340] [+] P0 TODO: check if branch exists
            if args.branch: t._branch = branch 
        elif args.subparser_name == 'workon':
            t._status = 'in-progress'
        elif args.subparser_name == 'finish':
            t._status = 'finished'
        elif args.subparser_name == 'cancel':
            t._status = 'cancelled'
        else:
            raise ValueError
    
        self.write_todos()
        
    def git_todo_detail(self, args):
        t = self.get_todo(args.uuid)

        print(t)
        params = ('branch', 'due', 'created', 'updated', 'category')
        maxlen = max(len(x) for x in params)
        for a in params:
            attr = '_' + a
            print(f"{a:>{maxlen}}: {getattr(t, attr)}")

    def git_todo_list(self, args):
        todos = self._todos

        if args.show == 'closed':
            todos = [ t for t in todos if ((t._status == 'cancelled') or 
                    (t._status == 'finished')) ]
        elif args.show:
            todos = [ t for t in todos if t._status == args.show ]
        # shortcuts for --show <status>
        elif args.new:
            todos = [ t for t in todos if t._status == 'new' ]
        elif args.open:
          todos = [ t for t in todos if t._status == 'open' ]
        elif args.in_progress:
          todos = [ t for t in todos if t._status == 'in-progress' ]
        elif args.finished:
          todos = [ t for t in todos if t._status == 'finished' ]
        elif args.cancelled:
          todos = [ t for t in todos if t._status == 'cancelled' ]
        elif args.closed:
            todos = [ t for t in todos if ((t._status == 'cancelled') or 
                    (t._status == 'finished')) ]

        #if hasattr(args, 'sort'):
        if args.sort == 'priority':
            todos = sorted(todos, key = lambda t: t._priority)
        elif args.sort == 'created':
            todos = sorted(todos, key = lambda t: t._created)
        elif args.sort == 'updated':
            todos = sorted(todos, key = lambda t: t._updated)
        elif args.sort == 'status':
            todos = sorted(todos, key = lambda t: t._status)

        for todo in todos.values():
            print(todo)

    def _scan_file(self, dirpath, fname, inplace=True):
        lines_to_replace = [ ]
        path = os.path.join(dirpath, fname)
        with open(path) as f:
            for index,line in enumerate(f.readlines()):
                match = TODO_REGEX.search(line)
                if match:
                    # found one!
                    self.logger.debug(f"Found match at {index}")
                    if match.group('ignore'): continue

                    if match.group('status') == None: # it's new
                        symbol = '+' 
                    elif match.group('status') == '+': # it was new last time
                        symbol = ' '
                    else:
                        symbol = match.group('status') # otherwise don't change it

                    t = ToDo(description = match.group('desc'), 
                            status = status_lookup[symbol], 
                            uuid = match.group('uuid') if match.group('uuid') else None,
                            loc = (path, index+1)
                            )
                    self.logger.debug(f"Created todo: {t}")
                    self.add_todo(t)
                    line = TODO_REGEX.sub(match.group('comment') + ' ' + str(t), line)
                            #line.replace('\n',''))
                    lines_to_replace.append( (index,line) )

        if lines_to_replace:
            replace_lines(dirpath, fname, lines_to_replace)

    def git_todo_scan(self, args):
        if args.ignore_from: ignore_from = parse_gitignore(args.ignore_from)
        if args.file: 
            try: self._scan_file(os.path.join(os.getcwd(), args.file))
            except: pass
            try: self._scan_file(os.path.join(self._root, args.file))
            except: pass
            return
    
        gitignore = os.path.join(self._root, '.gitignore')
        gitignore = parse_gitignore(gitignore)
    
        # walk the git root
        for dirpath, subdirs, fnames in os.walk(self._root):
            for fname in fnames:
                path = os.path.join(dirpath,fname)
                # if we're ignoring this file, skip it
                if gitignore(path) or fname == '.gitignore' or path == self.path or \
                        fname.startswith('.'): # path == os.path.abspath(__file__) or 
                    #self.logger.debug(f"Skipping {path}")
                    continue
                self.logger.debug(f"Scanning {path}")
                self._scan_file(dirpath, fname, args.inplace)

        self.write_todos()

    @property
    def path(self):
        return os.path.join(self._root, self._fname)

    def write_todos(self):
        with open(self.path, 'w') as f:
            json.dump(self._todos, f, cls=ToDoEncoder, indent=4)

    def read_todos(self):
        self._todos = { }
        try:
            with open(self.path, 'r') as f:
                self._todos = json.load(f, object_hook = ToDo.from_dict)
        except FileNotFoundError:
            pass
        return self._todos

    def __iter__(self):
        return iter(self._todos)

if __name__ == '__main__':
    ToDoList()


